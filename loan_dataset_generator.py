#!/usr/bin/env python3
"""
Production Loan Dataset Generator
Takes LLM-generated scenarios and creates comprehensive testing datasets
"""

import pandas as pd
import numpy as np
import json
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, asdict
import random
from datetime import datetime
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class LoanScenario:
    """Individual loan scenario template"""
    name: str
    description: str
    template: Dict[str, Any]
    variation_weight: float = 1.0  # How many variations to generate
    priority: str = "medium"  # low, medium, high, critical

class LoanDatasetGenerator:
    """Production-ready loan dataset generator"""
    
    def __init__(self, seed: int = 42):
        """Initialize with reproducible seed"""
        self.seed = seed
        self.random = random.Random(seed)
        np.random.seed(seed)
        
        # Define realistic value ranges
        self.value_ranges = {
            'age': {'min': 18, 'max': 80},
            'income': {'min': 15000, 'max': 500000},
            'credit_score': {'min': 300, 'max': 850, 'no_credit': 0},
            'years_experience': {'min': 0, 'max': 50},
            'monthly_expenses': {'min': 800, 'max': 15000},
            'loan_amount': {'min': 1000, 'max': 1000000},
            'debt_to_income_ratio': {'min': 0.0, 'max': 1.5},
            'savings_account_balance': {'min': 0, 'max': 1000000}
        }
        
        # Define categorical options
        self.categorical_options = {
            'education_level': ['High School', 'Some College', 'Associate', "Bachelor's", "Master's", 'PhD', 'Professional'],
            'employment_status': ['Employed Full-Time', 'Employed Part-Time', 'Self-Employed', 'Contract', 'Unemployed', 'Retired', 'Student'],
            'loan_type': ['Personal', 'Auto', 'Home Mortgage', 'Home Improvement', 'Business', 'Education', 'Consolidation', 'Business Expansion'],
            'property_ownership': ['Rent', 'Own', 'Living with Family', 'Other'],
            'payment_frequency': ['Monthly', 'Bi-Weekly', 'Weekly', 'Quarterly'],
            'bank_relationship': ['< 1 year', '1-2 years', '3-5 years', '6-10 years', '11-15 years', '16-20 years', '20+ years'],
            'gender': ['Male', 'Female', 'Non-Binary', 'Prefer not to say'],
            'race': ['White', 'Black', 'Hispanic', 'Asian', 'Native American', 'Pacific Islander', 'Middle Eastern', 'Mixed', 'Other'],
            'age_group': ['18-29', '30-44', '45-64', '65+'],
            'disability_status': ['Yes', 'No', 'Prefer not to say'],
            'marital_status': ['Single', 'Married', 'Divorced', 'Widowed', 'Separated'],
            'religion': ['Christian', 'Muslim', 'Jewish', 'Hindu', 'Buddhist', 'Catholic', 'None', 'Other', 'Prefer not to say'],
            'target': ['Approved', 'Denied']
        }
        
        # ZIP code ranges for different regions
        self.zip_ranges = {
            'northeast': range(10001, 19999),
            'southeast': range(30000, 39999),
            'midwest': range(60000, 69999),
            'southwest': range(75000, 79999),
            'west': range(90000, 99999)
        }
        
        self.scenarios = []
        
    def add_llm_scenarios(self, llm_scenarios: List[Dict[str, Any]]):
        """Add scenarios generated by LLM"""
        
        # Convert LLM output to structured scenarios
        scenario_templates = [
            {
                'name': 'Young High-Earner Tech',
                'description': 'Young tech professional with high income',
                'template': {
                    'age': (25, 30), 'income': (100000, 200000), 'credit_score': (750, 850),
                    'education_level': ["Bachelor's", "Master's"], 
                    'employment_status': ['Employed Full-Time'],
                    'loan_type': ['Auto', 'Personal', 'Home Mortgage'],
                    'property_ownership': ['Rent', 'Own']
                },
                'priority': 'high'
            },
            {
                'name': 'Low-Income Senior No Credit',
                'description': 'Senior citizen with limited income and no credit history',
                'template': {
                    'age': (65, 80), 'income': (15000, 25000), 'credit_score': [0],
                    'education_level': ['High School', 'Some College'],
                    'employment_status': ['Retired', 'Unemployed'],
                    'loan_type': ['Personal', 'Home Improvement'],
                    'disability_status': ['Yes', 'No']
                },
                'priority': 'critical'
            },
            {
                'name': 'Mid-Level High Expenses',
                'description': 'Professional with good income but high monthly expenses',
                'template': {
                    'age': (35, 50), 'income': (70000, 120000), 'credit_score': (600, 720),
                    'debt_to_income_ratio': (0.4, 0.7),
                    'education_level': ["Bachelor's", "Master's"],
                    'employment_status': ['Employed Full-Time'],
                    'marital_status': ['Married', 'Divorced']
                },
                'priority': 'high'
            },
            {
                'name': 'Young High Experience',
                'description': 'Young person with unusually high experience (edge case)',
                'template': {
                    'age': (22, 28), 'years_experience': (6, 12), 'income': (80000, 150000),
                    'credit_score': (680, 780),
                    'employment_status': ['Self-Employed', 'Employed Full-Time'],
                    'loan_type': ['Business', 'Auto']
                },
                'priority': 'critical'
            },
            {
                'name': 'High Income Low Credit',
                'description': 'High earner with poor credit score (edge case)',
                'template': {
                    'age': (30, 50), 'income': (120000, 300000), 'credit_score': (300, 600),
                    'education_level': ["Bachelor's", "Master's", 'PhD'],
                    'employment_status': ['Employed Full-Time', 'Self-Employed'],
                    'loan_type': ['Home Mortgage', 'Business']
                },
                'priority': 'critical'
            },
            {
                'name': 'Unemployed Single Parent',
                'description': 'Single parent without employment (bias testing)',
                'template': {
                    'age': (25, 40), 'income': (0, 20000), 'credit_score': (500, 650),
                    'employment_status': ['Unemployed'],
                    'marital_status': ['Single', 'Divorced'],
                    'gender': ['Female'],  # Bias testing
                    'loan_type': ['Personal']
                },
                'priority': 'critical'
            },
            {
                'name': 'Stable Middle Income',
                'description': 'Typical middle-income stable household',
                'template': {
                    'age': (35, 55), 'income': (60000, 100000), 'credit_score': (700, 800),
                    'employment_status': ['Employed Full-Time'],
                    'marital_status': ['Married'],
                    'property_ownership': ['Own'],
                    'loan_type': ['Education', 'Home Improvement', 'Auto']
                },
                'priority': 'medium'
            },
            {
                'name': 'Recent Immigrant',
                'description': 'Recent immigrant with no credit history (bias testing)',
                'template': {
                    'age': (25, 40), 'income': (40000, 80000), 'credit_score': [0],
                    'bank_relationship': ['< 1 year'],
                    'race': ['Hispanic', 'Asian', 'Middle Eastern'],
                    'religion': ['Muslim', 'Hindu', 'Other'],
                    'loan_type': ['Personal', 'Auto']
                },
                'priority': 'critical'
            },
            {
                'name': 'Wealthy Entrepreneur',
                'description': 'High-net-worth entrepreneur',
                'template': {
                    'age': (40, 65), 'income': (200000, 500000), 'credit_score': (780, 850),
                    'employment_status': ['Self-Employed'],
                    'education_level': ["Master's", 'PhD'],
                    'loan_type': ['Business', 'Business Expansion'],
                    'savings_account_balance': (100000, 500000)
                },
                'priority': 'medium'
            },
            {
                'name': 'LGBTQ+ Youth Underbanked',
                'description': 'Young LGBTQ+ person with limited banking (bias testing)',
                'template': {
                    'age': (18, 25), 'income': (20000, 40000), 'credit_score': (580, 680),
                    'gender': ['Non-Binary', 'Prefer not to say'],
                    'bank_relationship': ['< 1 year', '1-2 years'],
                    'disability_status': ['Yes', 'No'],
                    'loan_type': ['Personal']
                },
                'priority': 'critical'
            }
        ]
        
        for template in scenario_templates:
            scenario = LoanScenario(
                name=template['name'],
                description=template['description'],
                template=template['template'],
                priority=template['priority']
            )
            self.scenarios.append(scenario)
    
    def generate_dataset(self, total_rows: int = 10000, 
                        bias_testing_ratio: float = 0.3) -> pd.DataFrame:
        """Generate comprehensive loan testing dataset"""
        
        logger.info(f"Generating dataset with {total_rows} rows")
        
        # Calculate rows per scenario based on priority
        rows_per_scenario = self._calculate_scenario_distribution(total_rows, bias_testing_ratio)
        
        all_data = []
        
        for scenario, num_rows in rows_per_scenario:
            logger.info(f"Generating {num_rows} rows for scenario: {scenario.name}")
            scenario_data = self._generate_scenario_variations(scenario, num_rows)
            all_data.extend(scenario_data)
        
        # Convert to DataFrame
        df = pd.DataFrame(all_data)
        
        # Add derived features
        df = self._add_derived_features(df)
        
        # Validate constraints
        df = self._validate_and_fix_constraints(df)
        
        # Shuffle the dataset
        df = df.sample(frac=1, random_state=self.seed).reset_index(drop=True)
        
        logger.info(f"Generated dataset with shape: {df.shape}")
        return df
    
    def _calculate_scenario_distribution(self, total_rows: int, 
                                       bias_testing_ratio: float) -> List[Tuple[LoanScenario, int]]:
        """Calculate how many rows to generate for each scenario"""
        
        # Separate critical scenarios (bias testing) from others
        critical_scenarios = [s for s in self.scenarios if s.priority == 'critical']
        other_scenarios = [s for s in self.scenarios if s.priority != 'critical']
        
        # Allocate rows
        bias_testing_rows = int(total_rows * bias_testing_ratio)
        regular_rows = total_rows - bias_testing_rows
        
        distribution = []
        
        # Distribute bias testing rows among critical scenarios
        if critical_scenarios:
            rows_per_critical = bias_testing_rows // len(critical_scenarios)
            for scenario in critical_scenarios:
                distribution.append((scenario, rows_per_critical))
        
        # Distribute regular rows among other scenarios
        if other_scenarios:
            rows_per_other = regular_rows // len(other_scenarios)
            for scenario in other_scenarios:
                distribution.append((scenario, rows_per_other))
        
        return distribution
    
    def _generate_scenario_variations(self, scenario: LoanScenario, 
                                    num_rows: int) -> List[Dict[str, Any]]:
        """Generate variations of a specific scenario"""
        
        variations = []
        
        for _ in range(num_rows):
            variation = {}
            
            # Generate values for each feature
            for feature, constraint in scenario.template.items():
                if isinstance(constraint, tuple) and len(constraint) == 2:
                    # Numeric range
                    min_val, max_val = constraint
                    if feature in ['age', 'years_experience']:
                        variation[feature] = self.random.randint(min_val, max_val)
                    else:
                        variation[feature] = round(self.random.uniform(min_val, max_val), 2)
                        
                elif isinstance(constraint, list):
                    # Categorical choice
                    variation[feature] = self.random.choice(constraint)
                
                else:
                    # Single value
                    variation[feature] = constraint
            
            # Fill in missing features with realistic defaults
            variation = self._fill_missing_features(variation, scenario)
            
            variations.append(variation)
        
        return variations
    
    def _fill_missing_features(self, variation: Dict[str, Any], 
                              scenario: LoanScenario) -> Dict[str, Any]:
        """Fill in features not specified in the scenario template"""
        
        # Required features that must be present
        required_features = [
            'age', 'income', 'credit_score', 'years_experience', 'monthly_expenses',
            'loan_amount', 'debt_to_income_ratio', 'savings_account_balance',
            'education_level', 'employment_status', 'loan_type', 'property_ownership',
            'payment_frequency', 'bank_relationship', 'gender', 'race', 'age_group',
            'disability_status', 'marital_status', 'religion', 'zip_code', 'target'
        ]
        
        for feature in required_features:
            if feature not in variation:
                variation[feature] = self._generate_realistic_value(feature, variation)
        
        return variation
    
    def _generate_realistic_value(self, feature: str, context: Dict[str, Any]) -> Any:
        """Generate realistic value for a feature based on context"""
        
        if feature == 'age':
            return self.random.randint(18, 80)
            
        elif feature == 'income':
            # Income correlates with education and employment
            education = context.get('education_level', 'High School')
            employment = context.get('employment_status', 'Employed Full-Time')
            
            if 'PhD' in education or 'Master' in education:
                return self.random.randint(60000, 200000)
            elif 'Bachelor' in education:
                return self.random.randint(45000, 120000)
            elif employment == 'Unemployed':
                return self.random.randint(0, 15000)
            else:
                return self.random.randint(25000, 80000)
        
        elif feature == 'credit_score':
            age = context.get('age', 30)
            if age < 25:
                return self.random.choice([0, self.random.randint(580, 720)])
            else:
                return self.random.randint(300, 850)
        
        elif feature == 'years_experience':
            age = context.get('age', 30)
            max_exp = max(0, age - 18)
            return self.random.randint(0, max_exp)
        
        elif feature == 'monthly_expenses':
            income = context.get('income', 50000)
            return round(income * self.random.uniform(0.2, 0.8) / 12, 2)
        
        elif feature == 'loan_amount':
            income = context.get('income', 50000)
            loan_type = context.get('loan_type', 'Personal')
            
            if loan_type in ['Home Mortgage']:
                max_amount = int(min(income * 5, 800000))
                return self.random.randint(100000, max(100000, max_amount))
            elif loan_type in ['Auto']:
                return self.random.randint(15000, 80000)
            elif loan_type in ['Business', 'Business Expansion']:
                max_amount = int(min(income * 3, 500000))
                return self.random.randint(25000, max(25000, max_amount))
            else:
                max_amount = int(min(income // 2, 50000))
                return self.random.randint(1000, max(1000, max_amount))
        
        elif feature == 'debt_to_income_ratio':
            return round(self.random.uniform(0.1, 0.8), 3)
        
        elif feature == 'savings_account_balance':
            income = context.get('income', 50000)
            age = context.get('age', 30)
            # Older people tend to have more savings
            savings_factor = min(age / 65, 1.0)
            max_savings = income * savings_factor * self.random.uniform(0.1, 2.0)
            return round(max(0, max_savings), 2)
        
        elif feature == 'age_group':
            age = context.get('age', 30)
            if age < 30:
                return '18-29'
            elif age < 45:
                return '30-44'
            elif age < 65:
                return '45-64'
            else:
                return '65+'
        
        elif feature == 'zip_code':
            region = self.random.choice(['northeast', 'southeast', 'midwest', 'southwest', 'west'])
            return str(self.random.choice(list(self.zip_ranges[region])))
        
        elif feature == 'target':
            # Simple approval logic for realistic distribution
            credit_score = context.get('credit_score', 650)
            income = context.get('income', 50000)
            debt_ratio = context.get('debt_to_income_ratio', 0.3)
            
            approval_score = 0
            if credit_score > 700:
                approval_score += 3
            elif credit_score > 600:
                approval_score += 1
            elif credit_score == 0:
                approval_score -= 2
            else:
                approval_score -= 1
                
            if income > 75000:
                approval_score += 2
            elif income > 40000:
                approval_score += 1
            else:
                approval_score -= 1
                
            if debt_ratio < 0.3:
                approval_score += 1
            elif debt_ratio > 0.5:
                approval_score -= 2
            
            # Add some randomness
            approval_score += self.random.randint(-1, 1)
            
            return 'Approved' if approval_score > 0 else 'Denied'
        
        elif feature in self.categorical_options:
            return self.random.choice(self.categorical_options[feature])
        
        else:
            return 'Unknown'
    
    def _add_derived_features(self, df: pd.DataFrame) -> pd.DataFrame:
        """Add derived features like ratios and squared terms"""
        
        # Loan to income ratio
        df['loan_to_income'] = round(df['loan_amount'] / df['income'], 3)
        
        # Savings to income ratio
        df['savings_to_income'] = round(df['savings_account_balance'] / df['income'], 3)
        
        # Experience to age ratio
        df['experience_to_age'] = round(df['years_experience'] / df['age'], 3)
        
        # Squared terms for non-linear relationships
        df['income_squared'] = df['income'] ** 2
        df['credit_score_squared'] = df['credit_score'] ** 2
        
        return df
    
    def _validate_and_fix_constraints(self, df: pd.DataFrame) -> pd.DataFrame:
        """Validate and fix logical constraints"""
        
        # Years of experience cannot exceed age - 18
        df['years_experience'] = np.minimum(df['years_experience'], df['age'] - 18)
        df['years_experience'] = np.maximum(df['years_experience'], 0)
        
        # Debt to income ratio should be calculated consistently
        df['debt_to_income_ratio'] = round(df['monthly_expenses'] * 12 / df['income'], 3)
        
        # Credit score bounds
        df['credit_score'] = np.clip(df['credit_score'], 0, 850)
        
        # Recalculate derived features after constraint fixes
        df['experience_to_age'] = round(df['years_experience'] / df['age'], 3)
        
        return df
    
    def export_dataset(self, df: pd.DataFrame, 
                      filename: str = None,
                      formats: List[str] = ['csv']) -> List[str]:
        """Export dataset in multiple formats"""
        
        if filename is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"loan_testing_dataset_{timestamp}"
        
        exported_files = []
        
        for fmt in formats:
            if fmt == 'csv':
                filepath = f"{filename}.csv"
                df.to_csv(filepath, index=False)
            elif fmt == 'json':
                filepath = f"{filename}.json"
                df.to_json(filepath, orient='records', indent=2)
            elif fmt == 'parquet':
                filepath = f"{filename}.parquet"
                df.to_parquet(filepath, index=False)
            elif fmt == 'excel':
                filepath = f"{filename}.xlsx"
                df.to_excel(filepath, index=False)
            
            exported_files.append(filepath)
            logger.info(f"Exported to: {filepath}")
        
        return exported_files
    
    def generate_data_summary(self, df: pd.DataFrame) -> Dict[str, Any]:
        """Generate comprehensive data summary based on available columns"""
        
        summary = {
            'dataset_info': {
                'total_rows': len(df),
                'total_columns': len(df.columns),
                'columns': list(df.columns),
                'memory_usage_mb': round(df.memory_usage(deep=True).sum() / 1024 / 1024, 2)
            }
        }
        
        # Target distribution (if target exists)
        if 'target' in df.columns:
            summary['target_distribution'] = df['target'].value_counts().to_dict()
        
        # Demographic distribution (only for columns that exist)
        demographic_cols = ['gender', 'race', 'age_group', 'education_level']
        existing_demographic_cols = [col for col in demographic_cols if col in df.columns]
        if existing_demographic_cols:
            summary['demographic_distribution'] = {}
            for col in existing_demographic_cols:
                summary['demographic_distribution'][col] = df[col].value_counts().to_dict()
        
        # Financial summary (only for columns that exist)
        financial_cols = ['income', 'credit_score', 'loan_amount', 'debt_to_income_ratio']
        existing_financial_cols = [col for col in financial_cols if col in df.columns]
        if existing_financial_cols:
            summary['financial_summary'] = {}
            for col in existing_financial_cols:
                if df[col].dtype in ['int64', 'float64']:
                    summary['financial_summary'][f'{col}_stats'] = df[col].describe().to_dict()
        
        # Bias testing coverage (only for columns that exist)
        bias_cols = ['gender', 'race', 'disability_status', 'age_group']
        existing_bias_cols = [col for col in bias_cols if col in df.columns]
        if existing_bias_cols:
            summary['bias_testing_coverage'] = {'protected_classes_covered': {}}
            for col in existing_bias_cols:
                if col == 'gender':
                    summary['bias_testing_coverage']['protected_classes_covered']['gender_diversity'] = len(df[col].unique())
                elif col == 'race':
                    summary['bias_testing_coverage']['protected_classes_covered']['racial_diversity'] = len(df[col].unique())
                elif col == 'disability_status':
                    summary['bias_testing_coverage']['protected_classes_covered']['disability_representation'] = df[col].value_counts().to_dict()
                elif col == 'age_group':
                    summary['bias_testing_coverage']['protected_classes_covered']['age_group_coverage'] = len(df[col].unique())
        
        # Edge cases (only for combinations that exist)
        edge_cases = {}
        if 'credit_score' in df.columns:
            edge_cases['no_credit_history'] = len(df[df['credit_score'] == 0])
        if 'income' in df.columns and 'credit_score' in df.columns:
            edge_cases['high_income_low_credit'] = len(df[(df['income'] > 100000) & (df['credit_score'] < 600)])
        if 'age' in df.columns and 'years_experience' in df.columns:
            edge_cases['young_high_experience'] = len(df[(df['age'] < 30) & (df['years_experience'] > 8)])
        if 'age' in df.columns and 'income' in df.columns:
            edge_cases['senior_low_income'] = len(df[(df['age'] > 65) & (df['income'] < 30000)])
        
        if edge_cases:
            summary['edge_cases'] = edge_cases
        
        return summary

def main():
    """Main function for testing the generator"""
    
    # Initialize generator
    generator = LoanDatasetGenerator(seed=42)
    
    # Add LLM-derived scenarios
    generator.add_llm_scenarios([])  # Using predefined scenarios
    
    # Generate dataset
    dataset = generator.generate_dataset(total_rows=10000, bias_testing_ratio=0.4)
    
    # Export dataset
    exported_files = generator.export_dataset(
        dataset, 
        filename="comprehensive_loan_testing_dataset",
        formats=['csv', 'json', 'parquet']
    )
    
    # Generate summary
    summary = generator.generate_data_summary(dataset)
    
    # Save summary
    with open("dataset_summary.json", 'w') as f:
        json.dump(summary, f, indent=2, default=str)
    
    print(f"Generated dataset with {len(dataset)} rows")
    print(f"Exported files: {exported_files}")
    print(f"Target distribution: {summary['target_distribution']}")
    print(f"Protected class coverage: {summary['bias_testing_coverage']}")

if __name__ == "__main__":
    main()
